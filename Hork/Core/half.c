/*

Hork Engine Source Code

MIT License

Copyright (C) 2017-2024 Alexander Samusev.

This file is part of the Hork Engine Source Code.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

*/

#include <stdint.h>

static uint32_t MantissaTable[2048] = {
    0x00000000, 0x33800000, 0x34000000, 0x34400000, 0x34800000, 0x34a00000, 0x34c00000, 0x34e00000,
    0x35000000, 0x35100000, 0x35200000, 0x35300000, 0x35400000, 0x35500000, 0x35600000, 0x35700000,
    0x35800000, 0x35880000, 0x35900000, 0x35980000, 0x35a00000, 0x35a80000, 0x35b00000, 0x35b80000,
    0x35c00000, 0x35c80000, 0x35d00000, 0x35d80000, 0x35e00000, 0x35e80000, 0x35f00000, 0x35f80000,
    0x36000000, 0x36040000, 0x36080000, 0x360c0000, 0x36100000, 0x36140000, 0x36180000, 0x361c0000,
    0x36200000, 0x36240000, 0x36280000, 0x362c0000, 0x36300000, 0x36340000, 0x36380000, 0x363c0000,
    0x36400000, 0x36440000, 0x36480000, 0x364c0000, 0x36500000, 0x36540000, 0x36580000, 0x365c0000,
    0x36600000, 0x36640000, 0x36680000, 0x366c0000, 0x36700000, 0x36740000, 0x36780000, 0x367c0000,
    0x36800000, 0x36820000, 0x36840000, 0x36860000, 0x36880000, 0x368a0000, 0x368c0000, 0x368e0000,
    0x36900000, 0x36920000, 0x36940000, 0x36960000, 0x36980000, 0x369a0000, 0x369c0000, 0x369e0000,
    0x36a00000, 0x36a20000, 0x36a40000, 0x36a60000, 0x36a80000, 0x36aa0000, 0x36ac0000, 0x36ae0000,
    0x36b00000, 0x36b20000, 0x36b40000, 0x36b60000, 0x36b80000, 0x36ba0000, 0x36bc0000, 0x36be0000,
    0x36c00000, 0x36c20000, 0x36c40000, 0x36c60000, 0x36c80000, 0x36ca0000, 0x36cc0000, 0x36ce0000,
    0x36d00000, 0x36d20000, 0x36d40000, 0x36d60000, 0x36d80000, 0x36da0000, 0x36dc0000, 0x36de0000,
    0x36e00000, 0x36e20000, 0x36e40000, 0x36e60000, 0x36e80000, 0x36ea0000, 0x36ec0000, 0x36ee0000,
    0x36f00000, 0x36f20000, 0x36f40000, 0x36f60000, 0x36f80000, 0x36fa0000, 0x36fc0000, 0x36fe0000,
    0x37000000, 0x37010000, 0x37020000, 0x37030000, 0x37040000, 0x37050000, 0x37060000, 0x37070000,
    0x37080000, 0x37090000, 0x370a0000, 0x370b0000, 0x370c0000, 0x370d0000, 0x370e0000, 0x370f0000,
    0x37100000, 0x37110000, 0x37120000, 0x37130000, 0x37140000, 0x37150000, 0x37160000, 0x37170000,
    0x37180000, 0x37190000, 0x371a0000, 0x371b0000, 0x371c0000, 0x371d0000, 0x371e0000, 0x371f0000,
    0x37200000, 0x37210000, 0x37220000, 0x37230000, 0x37240000, 0x37250000, 0x37260000, 0x37270000,
    0x37280000, 0x37290000, 0x372a0000, 0x372b0000, 0x372c0000, 0x372d0000, 0x372e0000, 0x372f0000,
    0x37300000, 0x37310000, 0x37320000, 0x37330000, 0x37340000, 0x37350000, 0x37360000, 0x37370000,
    0x37380000, 0x37390000, 0x373a0000, 0x373b0000, 0x373c0000, 0x373d0000, 0x373e0000, 0x373f0000,
    0x37400000, 0x37410000, 0x37420000, 0x37430000, 0x37440000, 0x37450000, 0x37460000, 0x37470000,
    0x37480000, 0x37490000, 0x374a0000, 0x374b0000, 0x374c0000, 0x374d0000, 0x374e0000, 0x374f0000,
    0x37500000, 0x37510000, 0x37520000, 0x37530000, 0x37540000, 0x37550000, 0x37560000, 0x37570000,
    0x37580000, 0x37590000, 0x375a0000, 0x375b0000, 0x375c0000, 0x375d0000, 0x375e0000, 0x375f0000,
    0x37600000, 0x37610000, 0x37620000, 0x37630000, 0x37640000, 0x37650000, 0x37660000, 0x37670000,
    0x37680000, 0x37690000, 0x376a0000, 0x376b0000, 0x376c0000, 0x376d0000, 0x376e0000, 0x376f0000,
    0x37700000, 0x37710000, 0x37720000, 0x37730000, 0x37740000, 0x37750000, 0x37760000, 0x37770000,
    0x37780000, 0x37790000, 0x377a0000, 0x377b0000, 0x377c0000, 0x377d0000, 0x377e0000, 0x377f0000,
    0x37800000, 0x37808000, 0x37810000, 0x37818000, 0x37820000, 0x37828000, 0x37830000, 0x37838000,
    0x37840000, 0x37848000, 0x37850000, 0x37858000, 0x37860000, 0x37868000, 0x37870000, 0x37878000,
    0x37880000, 0x37888000, 0x37890000, 0x37898000, 0x378a0000, 0x378a8000, 0x378b0000, 0x378b8000,
    0x378c0000, 0x378c8000, 0x378d0000, 0x378d8000, 0x378e0000, 0x378e8000, 0x378f0000, 0x378f8000,
    0x37900000, 0x37908000, 0x37910000, 0x37918000, 0x37920000, 0x37928000, 0x37930000, 0x37938000,
    0x37940000, 0x37948000, 0x37950000, 0x37958000, 0x37960000, 0x37968000, 0x37970000, 0x37978000,
    0x37980000, 0x37988000, 0x37990000, 0x37998000, 0x379a0000, 0x379a8000, 0x379b0000, 0x379b8000,
    0x379c0000, 0x379c8000, 0x379d0000, 0x379d8000, 0x379e0000, 0x379e8000, 0x379f0000, 0x379f8000,
    0x37a00000, 0x37a08000, 0x37a10000, 0x37a18000, 0x37a20000, 0x37a28000, 0x37a30000, 0x37a38000,
    0x37a40000, 0x37a48000, 0x37a50000, 0x37a58000, 0x37a60000, 0x37a68000, 0x37a70000, 0x37a78000,
    0x37a80000, 0x37a88000, 0x37a90000, 0x37a98000, 0x37aa0000, 0x37aa8000, 0x37ab0000, 0x37ab8000,
    0x37ac0000, 0x37ac8000, 0x37ad0000, 0x37ad8000, 0x37ae0000, 0x37ae8000, 0x37af0000, 0x37af8000,
    0x37b00000, 0x37b08000, 0x37b10000, 0x37b18000, 0x37b20000, 0x37b28000, 0x37b30000, 0x37b38000,
    0x37b40000, 0x37b48000, 0x37b50000, 0x37b58000, 0x37b60000, 0x37b68000, 0x37b70000, 0x37b78000,
    0x37b80000, 0x37b88000, 0x37b90000, 0x37b98000, 0x37ba0000, 0x37ba8000, 0x37bb0000, 0x37bb8000,
    0x37bc0000, 0x37bc8000, 0x37bd0000, 0x37bd8000, 0x37be0000, 0x37be8000, 0x37bf0000, 0x37bf8000,
    0x37c00000, 0x37c08000, 0x37c10000, 0x37c18000, 0x37c20000, 0x37c28000, 0x37c30000, 0x37c38000,
    0x37c40000, 0x37c48000, 0x37c50000, 0x37c58000, 0x37c60000, 0x37c68000, 0x37c70000, 0x37c78000,
    0x37c80000, 0x37c88000, 0x37c90000, 0x37c98000, 0x37ca0000, 0x37ca8000, 0x37cb0000, 0x37cb8000,
    0x37cc0000, 0x37cc8000, 0x37cd0000, 0x37cd8000, 0x37ce0000, 0x37ce8000, 0x37cf0000, 0x37cf8000,
    0x37d00000, 0x37d08000, 0x37d10000, 0x37d18000, 0x37d20000, 0x37d28000, 0x37d30000, 0x37d38000,
    0x37d40000, 0x37d48000, 0x37d50000, 0x37d58000, 0x37d60000, 0x37d68000, 0x37d70000, 0x37d78000,
    0x37d80000, 0x37d88000, 0x37d90000, 0x37d98000, 0x37da0000, 0x37da8000, 0x37db0000, 0x37db8000,
    0x37dc0000, 0x37dc8000, 0x37dd0000, 0x37dd8000, 0x37de0000, 0x37de8000, 0x37df0000, 0x37df8000,
    0x37e00000, 0x37e08000, 0x37e10000, 0x37e18000, 0x37e20000, 0x37e28000, 0x37e30000, 0x37e38000,
    0x37e40000, 0x37e48000, 0x37e50000, 0x37e58000, 0x37e60000, 0x37e68000, 0x37e70000, 0x37e78000,
    0x37e80000, 0x37e88000, 0x37e90000, 0x37e98000, 0x37ea0000, 0x37ea8000, 0x37eb0000, 0x37eb8000,
    0x37ec0000, 0x37ec8000, 0x37ed0000, 0x37ed8000, 0x37ee0000, 0x37ee8000, 0x37ef0000, 0x37ef8000,
    0x37f00000, 0x37f08000, 0x37f10000, 0x37f18000, 0x37f20000, 0x37f28000, 0x37f30000, 0x37f38000,
    0x37f40000, 0x37f48000, 0x37f50000, 0x37f58000, 0x37f60000, 0x37f68000, 0x37f70000, 0x37f78000,
    0x37f80000, 0x37f88000, 0x37f90000, 0x37f98000, 0x37fa0000, 0x37fa8000, 0x37fb0000, 0x37fb8000,
    0x37fc0000, 0x37fc8000, 0x37fd0000, 0x37fd8000, 0x37fe0000, 0x37fe8000, 0x37ff0000, 0x37ff8000,
    0x38000000, 0x38004000, 0x38008000, 0x3800c000, 0x38010000, 0x38014000, 0x38018000, 0x3801c000,
    0x38020000, 0x38024000, 0x38028000, 0x3802c000, 0x38030000, 0x38034000, 0x38038000, 0x3803c000,
    0x38040000, 0x38044000, 0x38048000, 0x3804c000, 0x38050000, 0x38054000, 0x38058000, 0x3805c000,
    0x38060000, 0x38064000, 0x38068000, 0x3806c000, 0x38070000, 0x38074000, 0x38078000, 0x3807c000,
    0x38080000, 0x38084000, 0x38088000, 0x3808c000, 0x38090000, 0x38094000, 0x38098000, 0x3809c000,
    0x380a0000, 0x380a4000, 0x380a8000, 0x380ac000, 0x380b0000, 0x380b4000, 0x380b8000, 0x380bc000,
    0x380c0000, 0x380c4000, 0x380c8000, 0x380cc000, 0x380d0000, 0x380d4000, 0x380d8000, 0x380dc000,
    0x380e0000, 0x380e4000, 0x380e8000, 0x380ec000, 0x380f0000, 0x380f4000, 0x380f8000, 0x380fc000,
    0x38100000, 0x38104000, 0x38108000, 0x3810c000, 0x38110000, 0x38114000, 0x38118000, 0x3811c000,
    0x38120000, 0x38124000, 0x38128000, 0x3812c000, 0x38130000, 0x38134000, 0x38138000, 0x3813c000,
    0x38140000, 0x38144000, 0x38148000, 0x3814c000, 0x38150000, 0x38154000, 0x38158000, 0x3815c000,
    0x38160000, 0x38164000, 0x38168000, 0x3816c000, 0x38170000, 0x38174000, 0x38178000, 0x3817c000,
    0x38180000, 0x38184000, 0x38188000, 0x3818c000, 0x38190000, 0x38194000, 0x38198000, 0x3819c000,
    0x381a0000, 0x381a4000, 0x381a8000, 0x381ac000, 0x381b0000, 0x381b4000, 0x381b8000, 0x381bc000,
    0x381c0000, 0x381c4000, 0x381c8000, 0x381cc000, 0x381d0000, 0x381d4000, 0x381d8000, 0x381dc000,
    0x381e0000, 0x381e4000, 0x381e8000, 0x381ec000, 0x381f0000, 0x381f4000, 0x381f8000, 0x381fc000,
    0x38200000, 0x38204000, 0x38208000, 0x3820c000, 0x38210000, 0x38214000, 0x38218000, 0x3821c000,
    0x38220000, 0x38224000, 0x38228000, 0x3822c000, 0x38230000, 0x38234000, 0x38238000, 0x3823c000,
    0x38240000, 0x38244000, 0x38248000, 0x3824c000, 0x38250000, 0x38254000, 0x38258000, 0x3825c000,
    0x38260000, 0x38264000, 0x38268000, 0x3826c000, 0x38270000, 0x38274000, 0x38278000, 0x3827c000,
    0x38280000, 0x38284000, 0x38288000, 0x3828c000, 0x38290000, 0x38294000, 0x38298000, 0x3829c000,
    0x382a0000, 0x382a4000, 0x382a8000, 0x382ac000, 0x382b0000, 0x382b4000, 0x382b8000, 0x382bc000,
    0x382c0000, 0x382c4000, 0x382c8000, 0x382cc000, 0x382d0000, 0x382d4000, 0x382d8000, 0x382dc000,
    0x382e0000, 0x382e4000, 0x382e8000, 0x382ec000, 0x382f0000, 0x382f4000, 0x382f8000, 0x382fc000,
    0x38300000, 0x38304000, 0x38308000, 0x3830c000, 0x38310000, 0x38314000, 0x38318000, 0x3831c000,
    0x38320000, 0x38324000, 0x38328000, 0x3832c000, 0x38330000, 0x38334000, 0x38338000, 0x3833c000,
    0x38340000, 0x38344000, 0x38348000, 0x3834c000, 0x38350000, 0x38354000, 0x38358000, 0x3835c000,
    0x38360000, 0x38364000, 0x38368000, 0x3836c000, 0x38370000, 0x38374000, 0x38378000, 0x3837c000,
    0x38380000, 0x38384000, 0x38388000, 0x3838c000, 0x38390000, 0x38394000, 0x38398000, 0x3839c000,
    0x383a0000, 0x383a4000, 0x383a8000, 0x383ac000, 0x383b0000, 0x383b4000, 0x383b8000, 0x383bc000,
    0x383c0000, 0x383c4000, 0x383c8000, 0x383cc000, 0x383d0000, 0x383d4000, 0x383d8000, 0x383dc000,
    0x383e0000, 0x383e4000, 0x383e8000, 0x383ec000, 0x383f0000, 0x383f4000, 0x383f8000, 0x383fc000,
    0x38400000, 0x38404000, 0x38408000, 0x3840c000, 0x38410000, 0x38414000, 0x38418000, 0x3841c000,
    0x38420000, 0x38424000, 0x38428000, 0x3842c000, 0x38430000, 0x38434000, 0x38438000, 0x3843c000,
    0x38440000, 0x38444000, 0x38448000, 0x3844c000, 0x38450000, 0x38454000, 0x38458000, 0x3845c000,
    0x38460000, 0x38464000, 0x38468000, 0x3846c000, 0x38470000, 0x38474000, 0x38478000, 0x3847c000,
    0x38480000, 0x38484000, 0x38488000, 0x3848c000, 0x38490000, 0x38494000, 0x38498000, 0x3849c000,
    0x384a0000, 0x384a4000, 0x384a8000, 0x384ac000, 0x384b0000, 0x384b4000, 0x384b8000, 0x384bc000,
    0x384c0000, 0x384c4000, 0x384c8000, 0x384cc000, 0x384d0000, 0x384d4000, 0x384d8000, 0x384dc000,
    0x384e0000, 0x384e4000, 0x384e8000, 0x384ec000, 0x384f0000, 0x384f4000, 0x384f8000, 0x384fc000,
    0x38500000, 0x38504000, 0x38508000, 0x3850c000, 0x38510000, 0x38514000, 0x38518000, 0x3851c000,
    0x38520000, 0x38524000, 0x38528000, 0x3852c000, 0x38530000, 0x38534000, 0x38538000, 0x3853c000,
    0x38540000, 0x38544000, 0x38548000, 0x3854c000, 0x38550000, 0x38554000, 0x38558000, 0x3855c000,
    0x38560000, 0x38564000, 0x38568000, 0x3856c000, 0x38570000, 0x38574000, 0x38578000, 0x3857c000,
    0x38580000, 0x38584000, 0x38588000, 0x3858c000, 0x38590000, 0x38594000, 0x38598000, 0x3859c000,
    0x385a0000, 0x385a4000, 0x385a8000, 0x385ac000, 0x385b0000, 0x385b4000, 0x385b8000, 0x385bc000,
    0x385c0000, 0x385c4000, 0x385c8000, 0x385cc000, 0x385d0000, 0x385d4000, 0x385d8000, 0x385dc000,
    0x385e0000, 0x385e4000, 0x385e8000, 0x385ec000, 0x385f0000, 0x385f4000, 0x385f8000, 0x385fc000,
    0x38600000, 0x38604000, 0x38608000, 0x3860c000, 0x38610000, 0x38614000, 0x38618000, 0x3861c000,
    0x38620000, 0x38624000, 0x38628000, 0x3862c000, 0x38630000, 0x38634000, 0x38638000, 0x3863c000,
    0x38640000, 0x38644000, 0x38648000, 0x3864c000, 0x38650000, 0x38654000, 0x38658000, 0x3865c000,
    0x38660000, 0x38664000, 0x38668000, 0x3866c000, 0x38670000, 0x38674000, 0x38678000, 0x3867c000,
    0x38680000, 0x38684000, 0x38688000, 0x3868c000, 0x38690000, 0x38694000, 0x38698000, 0x3869c000,
    0x386a0000, 0x386a4000, 0x386a8000, 0x386ac000, 0x386b0000, 0x386b4000, 0x386b8000, 0x386bc000,
    0x386c0000, 0x386c4000, 0x386c8000, 0x386cc000, 0x386d0000, 0x386d4000, 0x386d8000, 0x386dc000,
    0x386e0000, 0x386e4000, 0x386e8000, 0x386ec000, 0x386f0000, 0x386f4000, 0x386f8000, 0x386fc000,
    0x38700000, 0x38704000, 0x38708000, 0x3870c000, 0x38710000, 0x38714000, 0x38718000, 0x3871c000,
    0x38720000, 0x38724000, 0x38728000, 0x3872c000, 0x38730000, 0x38734000, 0x38738000, 0x3873c000,
    0x38740000, 0x38744000, 0x38748000, 0x3874c000, 0x38750000, 0x38754000, 0x38758000, 0x3875c000,
    0x38760000, 0x38764000, 0x38768000, 0x3876c000, 0x38770000, 0x38774000, 0x38778000, 0x3877c000,
    0x38780000, 0x38784000, 0x38788000, 0x3878c000, 0x38790000, 0x38794000, 0x38798000, 0x3879c000,
    0x387a0000, 0x387a4000, 0x387a8000, 0x387ac000, 0x387b0000, 0x387b4000, 0x387b8000, 0x387bc000,
    0x387c0000, 0x387c4000, 0x387c8000, 0x387cc000, 0x387d0000, 0x387d4000, 0x387d8000, 0x387dc000,
    0x387e0000, 0x387e4000, 0x387e8000, 0x387ec000, 0x387f0000, 0x387f4000, 0x387f8000, 0x387fc000,
    0x00000000, 0x00002000, 0x00004000, 0x00006000, 0x00008000, 0x0000a000, 0x0000c000, 0x0000e000,
    0x00010000, 0x00012000, 0x00014000, 0x00016000, 0x00018000, 0x0001a000, 0x0001c000, 0x0001e000,
    0x00020000, 0x00022000, 0x00024000, 0x00026000, 0x00028000, 0x0002a000, 0x0002c000, 0x0002e000,
    0x00030000, 0x00032000, 0x00034000, 0x00036000, 0x00038000, 0x0003a000, 0x0003c000, 0x0003e000,
    0x00040000, 0x00042000, 0x00044000, 0x00046000, 0x00048000, 0x0004a000, 0x0004c000, 0x0004e000,
    0x00050000, 0x00052000, 0x00054000, 0x00056000, 0x00058000, 0x0005a000, 0x0005c000, 0x0005e000,
    0x00060000, 0x00062000, 0x00064000, 0x00066000, 0x00068000, 0x0006a000, 0x0006c000, 0x0006e000,
    0x00070000, 0x00072000, 0x00074000, 0x00076000, 0x00078000, 0x0007a000, 0x0007c000, 0x0007e000,
    0x00080000, 0x00082000, 0x00084000, 0x00086000, 0x00088000, 0x0008a000, 0x0008c000, 0x0008e000,
    0x00090000, 0x00092000, 0x00094000, 0x00096000, 0x00098000, 0x0009a000, 0x0009c000, 0x0009e000,
    0x000a0000, 0x000a2000, 0x000a4000, 0x000a6000, 0x000a8000, 0x000aa000, 0x000ac000, 0x000ae000,
    0x000b0000, 0x000b2000, 0x000b4000, 0x000b6000, 0x000b8000, 0x000ba000, 0x000bc000, 0x000be000,
    0x000c0000, 0x000c2000, 0x000c4000, 0x000c6000, 0x000c8000, 0x000ca000, 0x000cc000, 0x000ce000,
    0x000d0000, 0x000d2000, 0x000d4000, 0x000d6000, 0x000d8000, 0x000da000, 0x000dc000, 0x000de000,
    0x000e0000, 0x000e2000, 0x000e4000, 0x000e6000, 0x000e8000, 0x000ea000, 0x000ec000, 0x000ee000,
    0x000f0000, 0x000f2000, 0x000f4000, 0x000f6000, 0x000f8000, 0x000fa000, 0x000fc000, 0x000fe000,
    0x00100000, 0x00102000, 0x00104000, 0x00106000, 0x00108000, 0x0010a000, 0x0010c000, 0x0010e000,
    0x00110000, 0x00112000, 0x00114000, 0x00116000, 0x00118000, 0x0011a000, 0x0011c000, 0x0011e000,
    0x00120000, 0x00122000, 0x00124000, 0x00126000, 0x00128000, 0x0012a000, 0x0012c000, 0x0012e000,
    0x00130000, 0x00132000, 0x00134000, 0x00136000, 0x00138000, 0x0013a000, 0x0013c000, 0x0013e000,
    0x00140000, 0x00142000, 0x00144000, 0x00146000, 0x00148000, 0x0014a000, 0x0014c000, 0x0014e000,
    0x00150000, 0x00152000, 0x00154000, 0x00156000, 0x00158000, 0x0015a000, 0x0015c000, 0x0015e000,
    0x00160000, 0x00162000, 0x00164000, 0x00166000, 0x00168000, 0x0016a000, 0x0016c000, 0x0016e000,
    0x00170000, 0x00172000, 0x00174000, 0x00176000, 0x00178000, 0x0017a000, 0x0017c000, 0x0017e000,
    0x00180000, 0x00182000, 0x00184000, 0x00186000, 0x00188000, 0x0018a000, 0x0018c000, 0x0018e000,
    0x00190000, 0x00192000, 0x00194000, 0x00196000, 0x00198000, 0x0019a000, 0x0019c000, 0x0019e000,
    0x001a0000, 0x001a2000, 0x001a4000, 0x001a6000, 0x001a8000, 0x001aa000, 0x001ac000, 0x001ae000,
    0x001b0000, 0x001b2000, 0x001b4000, 0x001b6000, 0x001b8000, 0x001ba000, 0x001bc000, 0x001be000,
    0x001c0000, 0x001c2000, 0x001c4000, 0x001c6000, 0x001c8000, 0x001ca000, 0x001cc000, 0x001ce000,
    0x001d0000, 0x001d2000, 0x001d4000, 0x001d6000, 0x001d8000, 0x001da000, 0x001dc000, 0x001de000,
    0x001e0000, 0x001e2000, 0x001e4000, 0x001e6000, 0x001e8000, 0x001ea000, 0x001ec000, 0x001ee000,
    0x001f0000, 0x001f2000, 0x001f4000, 0x001f6000, 0x001f8000, 0x001fa000, 0x001fc000, 0x001fe000,
    0x00200000, 0x00202000, 0x00204000, 0x00206000, 0x00208000, 0x0020a000, 0x0020c000, 0x0020e000,
    0x00210000, 0x00212000, 0x00214000, 0x00216000, 0x00218000, 0x0021a000, 0x0021c000, 0x0021e000,
    0x00220000, 0x00222000, 0x00224000, 0x00226000, 0x00228000, 0x0022a000, 0x0022c000, 0x0022e000,
    0x00230000, 0x00232000, 0x00234000, 0x00236000, 0x00238000, 0x0023a000, 0x0023c000, 0x0023e000,
    0x00240000, 0x00242000, 0x00244000, 0x00246000, 0x00248000, 0x0024a000, 0x0024c000, 0x0024e000,
    0x00250000, 0x00252000, 0x00254000, 0x00256000, 0x00258000, 0x0025a000, 0x0025c000, 0x0025e000,
    0x00260000, 0x00262000, 0x00264000, 0x00266000, 0x00268000, 0x0026a000, 0x0026c000, 0x0026e000,
    0x00270000, 0x00272000, 0x00274000, 0x00276000, 0x00278000, 0x0027a000, 0x0027c000, 0x0027e000,
    0x00280000, 0x00282000, 0x00284000, 0x00286000, 0x00288000, 0x0028a000, 0x0028c000, 0x0028e000,
    0x00290000, 0x00292000, 0x00294000, 0x00296000, 0x00298000, 0x0029a000, 0x0029c000, 0x0029e000,
    0x002a0000, 0x002a2000, 0x002a4000, 0x002a6000, 0x002a8000, 0x002aa000, 0x002ac000, 0x002ae000,
    0x002b0000, 0x002b2000, 0x002b4000, 0x002b6000, 0x002b8000, 0x002ba000, 0x002bc000, 0x002be000,
    0x002c0000, 0x002c2000, 0x002c4000, 0x002c6000, 0x002c8000, 0x002ca000, 0x002cc000, 0x002ce000,
    0x002d0000, 0x002d2000, 0x002d4000, 0x002d6000, 0x002d8000, 0x002da000, 0x002dc000, 0x002de000,
    0x002e0000, 0x002e2000, 0x002e4000, 0x002e6000, 0x002e8000, 0x002ea000, 0x002ec000, 0x002ee000,
    0x002f0000, 0x002f2000, 0x002f4000, 0x002f6000, 0x002f8000, 0x002fa000, 0x002fc000, 0x002fe000,
    0x00300000, 0x00302000, 0x00304000, 0x00306000, 0x00308000, 0x0030a000, 0x0030c000, 0x0030e000,
    0x00310000, 0x00312000, 0x00314000, 0x00316000, 0x00318000, 0x0031a000, 0x0031c000, 0x0031e000,
    0x00320000, 0x00322000, 0x00324000, 0x00326000, 0x00328000, 0x0032a000, 0x0032c000, 0x0032e000,
    0x00330000, 0x00332000, 0x00334000, 0x00336000, 0x00338000, 0x0033a000, 0x0033c000, 0x0033e000,
    0x00340000, 0x00342000, 0x00344000, 0x00346000, 0x00348000, 0x0034a000, 0x0034c000, 0x0034e000,
    0x00350000, 0x00352000, 0x00354000, 0x00356000, 0x00358000, 0x0035a000, 0x0035c000, 0x0035e000,
    0x00360000, 0x00362000, 0x00364000, 0x00366000, 0x00368000, 0x0036a000, 0x0036c000, 0x0036e000,
    0x00370000, 0x00372000, 0x00374000, 0x00376000, 0x00378000, 0x0037a000, 0x0037c000, 0x0037e000,
    0x00380000, 0x00382000, 0x00384000, 0x00386000, 0x00388000, 0x0038a000, 0x0038c000, 0x0038e000,
    0x00390000, 0x00392000, 0x00394000, 0x00396000, 0x00398000, 0x0039a000, 0x0039c000, 0x0039e000,
    0x003a0000, 0x003a2000, 0x003a4000, 0x003a6000, 0x003a8000, 0x003aa000, 0x003ac000, 0x003ae000,
    0x003b0000, 0x003b2000, 0x003b4000, 0x003b6000, 0x003b8000, 0x003ba000, 0x003bc000, 0x003be000,
    0x003c0000, 0x003c2000, 0x003c4000, 0x003c6000, 0x003c8000, 0x003ca000, 0x003cc000, 0x003ce000,
    0x003d0000, 0x003d2000, 0x003d4000, 0x003d6000, 0x003d8000, 0x003da000, 0x003dc000, 0x003de000,
    0x003e0000, 0x003e2000, 0x003e4000, 0x003e6000, 0x003e8000, 0x003ea000, 0x003ec000, 0x003ee000,
    0x003f0000, 0x003f2000, 0x003f4000, 0x003f6000, 0x003f8000, 0x003fa000, 0x003fc000, 0x003fe000,
    0x00400000, 0x00402000, 0x00404000, 0x00406000, 0x00408000, 0x0040a000, 0x0040c000, 0x0040e000,
    0x00410000, 0x00412000, 0x00414000, 0x00416000, 0x00418000, 0x0041a000, 0x0041c000, 0x0041e000,
    0x00420000, 0x00422000, 0x00424000, 0x00426000, 0x00428000, 0x0042a000, 0x0042c000, 0x0042e000,
    0x00430000, 0x00432000, 0x00434000, 0x00436000, 0x00438000, 0x0043a000, 0x0043c000, 0x0043e000,
    0x00440000, 0x00442000, 0x00444000, 0x00446000, 0x00448000, 0x0044a000, 0x0044c000, 0x0044e000,
    0x00450000, 0x00452000, 0x00454000, 0x00456000, 0x00458000, 0x0045a000, 0x0045c000, 0x0045e000,
    0x00460000, 0x00462000, 0x00464000, 0x00466000, 0x00468000, 0x0046a000, 0x0046c000, 0x0046e000,
    0x00470000, 0x00472000, 0x00474000, 0x00476000, 0x00478000, 0x0047a000, 0x0047c000, 0x0047e000,
    0x00480000, 0x00482000, 0x00484000, 0x00486000, 0x00488000, 0x0048a000, 0x0048c000, 0x0048e000,
    0x00490000, 0x00492000, 0x00494000, 0x00496000, 0x00498000, 0x0049a000, 0x0049c000, 0x0049e000,
    0x004a0000, 0x004a2000, 0x004a4000, 0x004a6000, 0x004a8000, 0x004aa000, 0x004ac000, 0x004ae000,
    0x004b0000, 0x004b2000, 0x004b4000, 0x004b6000, 0x004b8000, 0x004ba000, 0x004bc000, 0x004be000,
    0x004c0000, 0x004c2000, 0x004c4000, 0x004c6000, 0x004c8000, 0x004ca000, 0x004cc000, 0x004ce000,
    0x004d0000, 0x004d2000, 0x004d4000, 0x004d6000, 0x004d8000, 0x004da000, 0x004dc000, 0x004de000,
    0x004e0000, 0x004e2000, 0x004e4000, 0x004e6000, 0x004e8000, 0x004ea000, 0x004ec000, 0x004ee000,
    0x004f0000, 0x004f2000, 0x004f4000, 0x004f6000, 0x004f8000, 0x004fa000, 0x004fc000, 0x004fe000,
    0x00500000, 0x00502000, 0x00504000, 0x00506000, 0x00508000, 0x0050a000, 0x0050c000, 0x0050e000,
    0x00510000, 0x00512000, 0x00514000, 0x00516000, 0x00518000, 0x0051a000, 0x0051c000, 0x0051e000,
    0x00520000, 0x00522000, 0x00524000, 0x00526000, 0x00528000, 0x0052a000, 0x0052c000, 0x0052e000,
    0x00530000, 0x00532000, 0x00534000, 0x00536000, 0x00538000, 0x0053a000, 0x0053c000, 0x0053e000,
    0x00540000, 0x00542000, 0x00544000, 0x00546000, 0x00548000, 0x0054a000, 0x0054c000, 0x0054e000,
    0x00550000, 0x00552000, 0x00554000, 0x00556000, 0x00558000, 0x0055a000, 0x0055c000, 0x0055e000,
    0x00560000, 0x00562000, 0x00564000, 0x00566000, 0x00568000, 0x0056a000, 0x0056c000, 0x0056e000,
    0x00570000, 0x00572000, 0x00574000, 0x00576000, 0x00578000, 0x0057a000, 0x0057c000, 0x0057e000,
    0x00580000, 0x00582000, 0x00584000, 0x00586000, 0x00588000, 0x0058a000, 0x0058c000, 0x0058e000,
    0x00590000, 0x00592000, 0x00594000, 0x00596000, 0x00598000, 0x0059a000, 0x0059c000, 0x0059e000,
    0x005a0000, 0x005a2000, 0x005a4000, 0x005a6000, 0x005a8000, 0x005aa000, 0x005ac000, 0x005ae000,
    0x005b0000, 0x005b2000, 0x005b4000, 0x005b6000, 0x005b8000, 0x005ba000, 0x005bc000, 0x005be000,
    0x005c0000, 0x005c2000, 0x005c4000, 0x005c6000, 0x005c8000, 0x005ca000, 0x005cc000, 0x005ce000,
    0x005d0000, 0x005d2000, 0x005d4000, 0x005d6000, 0x005d8000, 0x005da000, 0x005dc000, 0x005de000,
    0x005e0000, 0x005e2000, 0x005e4000, 0x005e6000, 0x005e8000, 0x005ea000, 0x005ec000, 0x005ee000,
    0x005f0000, 0x005f2000, 0x005f4000, 0x005f6000, 0x005f8000, 0x005fa000, 0x005fc000, 0x005fe000,
    0x00600000, 0x00602000, 0x00604000, 0x00606000, 0x00608000, 0x0060a000, 0x0060c000, 0x0060e000,
    0x00610000, 0x00612000, 0x00614000, 0x00616000, 0x00618000, 0x0061a000, 0x0061c000, 0x0061e000,
    0x00620000, 0x00622000, 0x00624000, 0x00626000, 0x00628000, 0x0062a000, 0x0062c000, 0x0062e000,
    0x00630000, 0x00632000, 0x00634000, 0x00636000, 0x00638000, 0x0063a000, 0x0063c000, 0x0063e000,
    0x00640000, 0x00642000, 0x00644000, 0x00646000, 0x00648000, 0x0064a000, 0x0064c000, 0x0064e000,
    0x00650000, 0x00652000, 0x00654000, 0x00656000, 0x00658000, 0x0065a000, 0x0065c000, 0x0065e000,
    0x00660000, 0x00662000, 0x00664000, 0x00666000, 0x00668000, 0x0066a000, 0x0066c000, 0x0066e000,
    0x00670000, 0x00672000, 0x00674000, 0x00676000, 0x00678000, 0x0067a000, 0x0067c000, 0x0067e000,
    0x00680000, 0x00682000, 0x00684000, 0x00686000, 0x00688000, 0x0068a000, 0x0068c000, 0x0068e000,
    0x00690000, 0x00692000, 0x00694000, 0x00696000, 0x00698000, 0x0069a000, 0x0069c000, 0x0069e000,
    0x006a0000, 0x006a2000, 0x006a4000, 0x006a6000, 0x006a8000, 0x006aa000, 0x006ac000, 0x006ae000,
    0x006b0000, 0x006b2000, 0x006b4000, 0x006b6000, 0x006b8000, 0x006ba000, 0x006bc000, 0x006be000,
    0x006c0000, 0x006c2000, 0x006c4000, 0x006c6000, 0x006c8000, 0x006ca000, 0x006cc000, 0x006ce000,
    0x006d0000, 0x006d2000, 0x006d4000, 0x006d6000, 0x006d8000, 0x006da000, 0x006dc000, 0x006de000,
    0x006e0000, 0x006e2000, 0x006e4000, 0x006e6000, 0x006e8000, 0x006ea000, 0x006ec000, 0x006ee000,
    0x006f0000, 0x006f2000, 0x006f4000, 0x006f6000, 0x006f8000, 0x006fa000, 0x006fc000, 0x006fe000,
    0x00700000, 0x00702000, 0x00704000, 0x00706000, 0x00708000, 0x0070a000, 0x0070c000, 0x0070e000,
    0x00710000, 0x00712000, 0x00714000, 0x00716000, 0x00718000, 0x0071a000, 0x0071c000, 0x0071e000,
    0x00720000, 0x00722000, 0x00724000, 0x00726000, 0x00728000, 0x0072a000, 0x0072c000, 0x0072e000,
    0x00730000, 0x00732000, 0x00734000, 0x00736000, 0x00738000, 0x0073a000, 0x0073c000, 0x0073e000,
    0x00740000, 0x00742000, 0x00744000, 0x00746000, 0x00748000, 0x0074a000, 0x0074c000, 0x0074e000,
    0x00750000, 0x00752000, 0x00754000, 0x00756000, 0x00758000, 0x0075a000, 0x0075c000, 0x0075e000,
    0x00760000, 0x00762000, 0x00764000, 0x00766000, 0x00768000, 0x0076a000, 0x0076c000, 0x0076e000,
    0x00770000, 0x00772000, 0x00774000, 0x00776000, 0x00778000, 0x0077a000, 0x0077c000, 0x0077e000,
    0x00780000, 0x00782000, 0x00784000, 0x00786000, 0x00788000, 0x0078a000, 0x0078c000, 0x0078e000,
    0x00790000, 0x00792000, 0x00794000, 0x00796000, 0x00798000, 0x0079a000, 0x0079c000, 0x0079e000,
    0x007a0000, 0x007a2000, 0x007a4000, 0x007a6000, 0x007a8000, 0x007aa000, 0x007ac000, 0x007ae000,
    0x007b0000, 0x007b2000, 0x007b4000, 0x007b6000, 0x007b8000, 0x007ba000, 0x007bc000, 0x007be000,
    0x007c0000, 0x007c2000, 0x007c4000, 0x007c6000, 0x007c8000, 0x007ca000, 0x007cc000, 0x007ce000,
    0x007d0000, 0x007d2000, 0x007d4000, 0x007d6000, 0x007d8000, 0x007da000, 0x007dc000, 0x007de000,
    0x007e0000, 0x007e2000, 0x007e4000, 0x007e6000, 0x007e8000, 0x007ea000, 0x007ec000, 0x007ee000,
    0x007f0000, 0x007f2000, 0x007f4000, 0x007f6000, 0x007f8000, 0x007fa000, 0x007fc000, 0x007fe000};
static uint32_t ExponentTable[64] = {
    0x00000000, 0x38800000, 0x39000000, 0x39800000, 0x3a000000, 0x3a800000, 0x3b000000, 0x3b800000,
    0x3c000000, 0x3c800000, 0x3d000000, 0x3d800000, 0x3e000000, 0x3e800000, 0x3f000000, 0x3f800000,
    0x40000000, 0x40800000, 0x41000000, 0x41800000, 0x42000000, 0x42800000, 0x43000000, 0x43800000,
    0x44000000, 0x44800000, 0x45000000, 0x45800000, 0x46000000, 0x46800000, 0x47000000, 0x7f800000,
    0x80000000, 0xb8800000, 0xb9000000, 0xb9800000, 0xba000000, 0xba800000, 0xbb000000, 0xbb800000,
    0xbc000000, 0xbc800000, 0xbd000000, 0xbd800000, 0xbe000000, 0xbe800000, 0xbf000000, 0xbf800000,
    0xc0000000, 0xc0800000, 0xc1000000, 0xc1800000, 0xc2000000, 0xc2800000, 0xc3000000, 0xc3800000,
    0xc4000000, 0xc4800000, 0xc5000000, 0xc5800000, 0xc6000000, 0xc6800000, 0xc7000000, 0xff800000};
static uint32_t OffsetTable[64] = {
    0x00000000, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000000, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400,
    0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400, 0x00000400};

uint32_t fast_half_to_float(uint16_t h)
{
    uint32_t exp = h >> 10;
    return MantissaTable[OffsetTable[exp] + (h & 0x3ff)] + ExponentTable[exp];
}

#if 0

// Fast half to float conversion based on:
// http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
struct FastHalfToFloat
{
    uint32_t m_MantissaTable[2048];
    uint32_t m_ExponentTable[64];
    uint32_t m_OffsetTable[64];

    FastHalfToFloat()
    {
        m_MantissaTable[0] = 0;
        for (int i = 1; i < 1024; i++)
        {
            uint32_t m = i << 13;
            uint32_t e = 0;
            while ((m & 0x00800000) == 0)
            {
                e -= 0x00800000;
                m <<= 1;
            }
            m &= ~0x00800000;
            e += 0x38800000;
            m_MantissaTable[i] = m | e;
        }
        for (int i = 1024; i < 2048; i++)
            m_MantissaTable[i] = (i - 1024) << 13;
        m_ExponentTable[0] = 0;
        for (int i = 1; i < 31; i++)
            m_ExponentTable[i] = 0x38000000 + (i << 23);
        m_ExponentTable[31] = 0x7f800000;
        m_ExponentTable[32] = 0x80000000;
        for (int i = 33; i < 63; i++)
            m_ExponentTable[i] = 0xb8000000 + ((i - 32) << 23);
        m_ExponentTable[63] = 0xff800000;
        m_OffsetTable[0]    = 0;
        for (int i = 1; i < 32; i++)
            m_OffsetTable[i] = 1024;
        m_OffsetTable[32] = 0;
        for (int i = 33; i < 64; i++)
            m_OffsetTable[i] = 1024;
    }

    HK_FORCEINLINE uint32_t Convert(uint16_t h) const
    {
        uint32_t exp = h >> 10;
        return m_MantissaTable[m_OffsetTable[exp] + (h & 0x3ff)] + m_ExponentTable[exp];
    }
};

static FastHalfToFloat GFastHalfToFloat;

#    include "IO.h"
void WriteTables()
{
    File f = File::OpenWrite("half.cpp");
    if (!f)
        return;
    f.FormattedPrint("static uint32_t MantissaTable[2048] = {{\n");
    for (int i = 0; i < 2048; i+=8)
    {
        if (i + 8 != 2048)
            f.FormattedPrint("    0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x},\n",
                GFastHalfToFloat.m_MantissaTable[i + 0],
                GFastHalfToFloat.m_MantissaTable[i + 1],
                GFastHalfToFloat.m_MantissaTable[i + 2],
                GFastHalfToFloat.m_MantissaTable[i + 3],
                GFastHalfToFloat.m_MantissaTable[i + 4],
                GFastHalfToFloat.m_MantissaTable[i + 5], 
                GFastHalfToFloat.m_MantissaTable[i + 6], 
                GFastHalfToFloat.m_MantissaTable[i + 7] );
        else
            f.FormattedPrint("    0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}\n",
                             GFastHalfToFloat.m_MantissaTable[i + 0],
                             GFastHalfToFloat.m_MantissaTable[i + 1],
                             GFastHalfToFloat.m_MantissaTable[i + 2],
                             GFastHalfToFloat.m_MantissaTable[i + 3],
                             GFastHalfToFloat.m_MantissaTable[i + 4],
                             GFastHalfToFloat.m_MantissaTable[i + 5],
                             GFastHalfToFloat.m_MantissaTable[i + 6],
                             GFastHalfToFloat.m_MantissaTable[i + 7]);
    }
    f.FormattedPrint("}};\n");

    f.FormattedPrint("static uint32_t ExponentTable[64] = {{\n");
    for (int i = 0; i < 64; i+=8)
    {
        if (i + 8 != 64)
            f.FormattedPrint("    0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x},\n",
                             GFastHalfToFloat.m_ExponentTable[i + 0],
                             GFastHalfToFloat.m_ExponentTable[i + 1],
                             GFastHalfToFloat.m_ExponentTable[i + 2],
                             GFastHalfToFloat.m_ExponentTable[i + 3],
                             GFastHalfToFloat.m_ExponentTable[i + 4],
                             GFastHalfToFloat.m_ExponentTable[i + 5],
                             GFastHalfToFloat.m_ExponentTable[i + 6],
                             GFastHalfToFloat.m_ExponentTable[i + 7]);
        else
            f.FormattedPrint("    0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}\n",
                             GFastHalfToFloat.m_ExponentTable[i + 0],
                             GFastHalfToFloat.m_ExponentTable[i + 1],
                             GFastHalfToFloat.m_ExponentTable[i + 2],
                             GFastHalfToFloat.m_ExponentTable[i + 3],
                             GFastHalfToFloat.m_ExponentTable[i + 4],
                             GFastHalfToFloat.m_ExponentTable[i + 5],
                             GFastHalfToFloat.m_ExponentTable[i + 6],
                             GFastHalfToFloat.m_ExponentTable[i + 7]);
    }
    f.FormattedPrint("}};\n");

    f.FormattedPrint("static uint32_t OffsetTable[64] = {{\n");
    for (int i = 0; i < 64; i+=8)
    {
        if (i + 8 != 64)
            f.FormattedPrint("    0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x},\n",
                             GFastHalfToFloat.m_OffsetTable[i + 0],
                             GFastHalfToFloat.m_OffsetTable[i + 1],
                             GFastHalfToFloat.m_OffsetTable[i + 2],
                             GFastHalfToFloat.m_OffsetTable[i + 3],
                             GFastHalfToFloat.m_OffsetTable[i + 4],
                             GFastHalfToFloat.m_OffsetTable[i + 5],
                             GFastHalfToFloat.m_OffsetTable[i + 6],
                             GFastHalfToFloat.m_OffsetTable[i + 7]);
        else
            f.FormattedPrint("    0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}, 0x{:08x}\n",
                             GFastHalfToFloat.m_OffsetTable[i + 0],
                             GFastHalfToFloat.m_OffsetTable[i + 1],
                             GFastHalfToFloat.m_OffsetTable[i + 2],
                             GFastHalfToFloat.m_OffsetTable[i + 3],
                             GFastHalfToFloat.m_OffsetTable[i + 4],
                             GFastHalfToFloat.m_OffsetTable[i + 5],
                             GFastHalfToFloat.m_OffsetTable[i + 6],
                             GFastHalfToFloat.m_OffsetTable[i + 7]);
    }
    f.FormattedPrint("}};\n");
}

uint32_t fast_half_to_float(uint16_t h)
{
    return GFastHalfToFloat.Convert(h);
}

#endif




// Branch-free implementation of half-precision (16 bit) floating point
// Copyright 2006 Mike Acton <macton@gmail.com>
// 
// Permission is hereby granted, free of charge, to any person obtaining a 
// copy of this software and associated documentation files (the "Software"),
// to deal in the Software without restriction, including without limitation
// the rights to use, copy, modify, merge, publish, distribute, sublicense, 
// and/or sell copies of the Software, and to permit persons to whom the 
// Software is furnished to do so, subject to the following conditions:
// 
// The above copyright notice and this permission notice shall be included 
// in all copies or substantial portions of the Software.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE
//
// Half-precision floating point format
// ------------------------------------
//
//   | Field    | Last | First | Note
//   |----------|------|-------|----------
//   | Sign     | 15   | 15    |
//   | Exponent | 14   | 10    | Bias = 15
//   | Mantissa | 9    | 0     |
//
// Compiling
// ---------
//
//  Preferred compile flags for GCC: 
//     -O3 -fstrict-aliasing -std=c99 -pedantic -Wall -Wstrict-aliasing
//
//     This file is a C99 source file, intended to be compiled with a C99 
//     compliant compiler. However, for the moment it remains combatible
//     with C++98. Therefore if you are using a compiler that poorly implements
//     C standards (e.g. MSVC), it may be compiled as C++. This is not
//     guaranteed for future versions. 
//

#ifdef _MSC_VER
#    pragma warning(disable : 4146) // unary minus operator applied to unsigned type, result still unsigned
#endif

// Load immediate
static inline uint32_t _uint32_li( uint32_t a )
{
  return (a);
}

// Decrement
static inline uint32_t _uint32_dec( uint32_t a )
{
  return (a - 1);
}

// Increment
static inline uint32_t _uint32_inc( uint32_t a )
{
  return (a + 1);
}

// Complement
static inline uint32_t _uint32_not( uint32_t a )
{
  return (~a);
}

// Negate
static inline uint32_t _uint32_neg( uint32_t a )
{
  return (-a);
}

// Extend sign
static inline uint32_t _uint32_ext( uint32_t a )
{
  return (((int32_t)a)>>31);
}

// And
static inline uint32_t _uint32_and( uint32_t a, uint32_t b )
{
  return (a & b);
}

// Exclusive Or
static inline uint32_t _uint32_xor( uint32_t a, uint32_t b )
{
  return (a ^ b);
}

// And with Complement
static inline uint32_t _uint32_andc( uint32_t a, uint32_t b )
{
  return (a & ~b);
}

// Or
static inline uint32_t _uint32_or( uint32_t a, uint32_t b )
{
  return (a | b);
}

// Shift Right Logical
static inline uint32_t _uint32_srl( uint32_t a, int sa )
{
  return (a >> sa);
}

// Shift Left Logical
static inline uint32_t _uint32_sll( uint32_t a, int sa )
{
  return (a << sa);
}

// Add
static inline uint32_t _uint32_add( uint32_t a, uint32_t b )
{
  return (a + b);
}

// Subtract
static inline uint32_t _uint32_sub( uint32_t a, uint32_t b )
{
  return (a - b);
}

// Multiply
static inline uint32_t _uint32_mul( uint32_t a, uint32_t b )
{
  return (a * b);
}

// Select on Sign bit
static inline uint32_t _uint32_sels( uint32_t test, uint32_t a, uint32_t b )
{
  const uint32_t mask   = _uint32_ext( test );
  const uint32_t sel_a  = _uint32_and(  a,     mask  );
  const uint32_t sel_b  = _uint32_andc( b,     mask  );
  const uint32_t result = _uint32_or(   sel_a, sel_b );

  return (result);
}

// Select Bits on mask
static inline uint32_t _uint32_selb( uint32_t mask, uint32_t a, uint32_t b )
{
  const uint32_t sel_a  = _uint32_and(  a,     mask  );
  const uint32_t sel_b  = _uint32_andc( b,     mask  );
  const uint32_t result = _uint32_or(   sel_a, sel_b );

  return (result);
}

// Load Immediate
static inline uint16_t _uint16_li( uint16_t a )
{
  return (a);
}

// Extend sign
static inline uint16_t _uint16_ext( uint16_t a )
{
  return (((int16_t)a)>>15);
}

// Negate
static inline uint16_t _uint16_neg( uint16_t a )
{
  return (-a);
}

// Complement
static inline uint16_t _uint16_not( uint16_t a )
{
  return (~a);
}

// Decrement
static inline uint16_t _uint16_dec( uint16_t a )
{
  return (a - 1);
}

// Shift Left Logical
static inline uint16_t _uint16_sll( uint16_t a, int sa )
{
  return (a << sa);
}

// Shift Right Logical
static inline uint16_t _uint16_srl( uint16_t a, int sa )
{
  return (a >> sa);
}

// Add
static inline uint16_t _uint16_add( uint16_t a, uint16_t b )
{
  return (a + b);
}

// Subtract
static inline uint16_t _uint16_sub( uint16_t a, uint16_t b )
{
  return (a - b);
}

// And
static inline uint16_t _uint16_and( uint16_t a, uint16_t b )
{
  return (a & b);
}

// Or
static inline uint16_t _uint16_or( uint16_t a, uint16_t b )
{
  return (a | b);
}

// Exclusive Or
static inline uint16_t _uint16_xor( uint16_t a, uint16_t b )
{
  return (a ^ b);
}

// And with Complement
static inline uint16_t _uint16_andc( uint16_t a, uint16_t b )
{
  return (a & ~b);
}

// And then Shift Right Logical
static inline uint16_t _uint16_andsrl( uint16_t a, uint16_t b, int sa )
{
  return ((a & b) >> sa);
}

// Shift Right Logical then Mask
static inline uint16_t _uint16_srlm( uint16_t a, int sa, uint16_t mask )
{
  return ((a >> sa) & mask);
}

// Add then Mask
static inline uint16_t _uint16_addm( uint16_t a, uint16_t b, uint16_t mask )
{
  return ((a + b) & mask);
}


// Select on Sign bit
static inline uint16_t _uint16_sels( uint16_t test, uint16_t a, uint16_t b )
{
  const uint16_t mask   = _uint16_ext( test );
  const uint16_t sel_a  = _uint16_and(  a,     mask  );
  const uint16_t sel_b  = _uint16_andc( b,     mask  );
  const uint16_t result = _uint16_or(   sel_a, sel_b );

  return (result);
}

// Count Leading Zeros
static inline uint32_t _uint32_cntlz( uint32_t x )
{
#ifdef __GNUC__
  /* NOTE: __builtin_clz is undefined for x == 0 */
  /* On PowerPC, this will map to insn: cntlzw   */
  /* On Pentium, this will map to insn: clz      */
  uint32_t is_x_nez_msb = _uint32_neg( x );
  uint32_t nlz          = __builtin_clz( x );
  uint32_t result       = _uint32_sels( is_x_nez_msb, nlz, 0x00000020 );
  return (result);
#else
  const uint32_t x0  = _uint32_srl(  x,  1 );
  const uint32_t x1  = _uint32_or(   x,  x0 );
  const uint32_t x2  = _uint32_srl(  x1, 2 );
  const uint32_t x3  = _uint32_or(   x1, x2 );
  const uint32_t x4  = _uint32_srl(  x3, 4 );
  const uint32_t x5  = _uint32_or(   x3, x4 );
  const uint32_t x6  = _uint32_srl(  x5, 8 );
  const uint32_t x7  = _uint32_or(   x5, x6 );
  const uint32_t x8  = _uint32_srl(  x7, 16 );
  const uint32_t x9  = _uint32_or(   x7, x8 );
  const uint32_t xA  = _uint32_not(  x9 );
  const uint32_t xB  = _uint32_srl(  xA, 1 );
  const uint32_t xC  = _uint32_and(  xB, 0x55555555 );
  const uint32_t xD  = _uint32_sub(  xA, xC );
  const uint32_t xE  = _uint32_and(  xD, 0x33333333 );
  const uint32_t xF  = _uint32_srl(  xD, 2 );
  const uint32_t x10 = _uint32_and(  xF, 0x33333333 );
  const uint32_t x11 = _uint32_add(  xE, x10 );
  const uint32_t x12 = _uint32_srl(  x11, 4 );
  const uint32_t x13 = _uint32_add(  x11, x12 );
  const uint32_t x14 = _uint32_and(  x13, 0x0f0f0f0f );
  const uint32_t x15 = _uint32_srl(  x14, 8 );
  const uint32_t x16 = _uint32_add(  x14, x15 );
  const uint32_t x17 = _uint32_srl(  x16, 16 );
  const uint32_t x18 = _uint32_add(  x16, x17 );
  const uint32_t x19 = _uint32_and(  x18, 0x0000003f );
  return ( x19 );
#endif
}

// Count Leading Zeros
static inline uint16_t _uint16_cntlz( uint16_t x )
{
#ifdef __GNUC__
  uint16_t nlz32 = (uint16_t)_uint32_cntlz( (uint32_t)x );
  uint32_t nlz   = _uint32_sub( nlz32, 16 );
  return (nlz);
#else
  const uint16_t x0  = _uint16_srl(  x,  1 );
  const uint16_t x1  = _uint16_or(   x,  x0 );
  const uint16_t x2  = _uint16_srl(  x1, 2 );
  const uint16_t x3  = _uint16_or(   x1, x2 );
  const uint16_t x4  = _uint16_srl(  x3, 4 );
  const uint16_t x5  = _uint16_or(   x3, x4 );
  const uint16_t x6  = _uint16_srl(  x5, 8 );
  const uint16_t x7  = _uint16_or(   x5, x6 );
  const uint16_t x8  = _uint16_not(  x7 );
  const uint16_t x9  = _uint16_srlm( x8, 1, 0x5555 );
  const uint16_t xA  = _uint16_sub(  x8, x9 );
  const uint16_t xB  = _uint16_and(  xA, 0x3333 );
  const uint16_t xC  = _uint16_srlm( xA, 2, 0x3333 );
  const uint16_t xD  = _uint16_add(  xB, xC );
  const uint16_t xE  = _uint16_srl(  xD, 4 );
  const uint16_t xF  = _uint16_addm( xD, xE, 0x0f0f );
  const uint16_t x10 = _uint16_srl(  xF, 8 );
  const uint16_t x11 = _uint16_addm( xF, x10, 0x001f );
  return ( x11 );
#endif
}

uint16_t
half_from_float( uint32_t f )
{
  const uint32_t one                        = _uint32_li( 0x00000001 );
  const uint32_t f_s_mask                   = _uint32_li( 0x80000000 );
  const uint32_t f_e_mask                   = _uint32_li( 0x7f800000 );
  const uint32_t f_m_mask                   = _uint32_li( 0x007fffff );
  const uint32_t f_m_hidden_bit             = _uint32_li( 0x00800000 );
  const uint32_t f_m_round_bit              = _uint32_li( 0x00001000 );
  const uint32_t f_snan_mask                = _uint32_li( 0x7fc00000 );
  const uint32_t f_e_pos                    = _uint32_li( 0x00000017 );
  const uint32_t h_e_pos                    = _uint32_li( 0x0000000a );
  const uint32_t h_e_mask                   = _uint32_li( 0x00007c00 );
  const uint32_t h_snan_mask                = _uint32_li( 0x00007e00 );
  const uint32_t h_e_mask_value             = _uint32_li( 0x0000001f );
  const uint32_t f_h_s_pos_offset           = _uint32_li( 0x00000010 );
  const uint32_t f_h_bias_offset            = _uint32_li( 0x00000070 );
  const uint32_t f_h_m_pos_offset           = _uint32_li( 0x0000000d );
  const uint32_t h_nan_min                  = _uint32_li( 0x00007c01 );
  const uint32_t f_h_e_biased_flag          = _uint32_li( 0x0000008f );
  const uint32_t f_s                        = _uint32_and( f,               f_s_mask         );
  const uint32_t f_e                        = _uint32_and( f,               f_e_mask         );
  const uint16_t h_s                        = _uint32_srl( f_s,             f_h_s_pos_offset );
  const uint32_t f_m                        = _uint32_and( f,               f_m_mask         );
  const uint16_t f_e_amount                 = _uint32_srl( f_e,             f_e_pos          );
  const uint32_t f_e_half_bias              = _uint32_sub( f_e_amount,      f_h_bias_offset  );
  const uint32_t f_snan                     = _uint32_and( f,               f_snan_mask      );
  const uint32_t f_m_round_mask             = _uint32_and( f_m,             f_m_round_bit    );
  const uint32_t f_m_round_offset           = _uint32_sll( f_m_round_mask,  one              );
  const uint32_t f_m_rounded                = _uint32_add( f_m,             f_m_round_offset );
  const uint32_t f_m_denorm_sa              = _uint32_sub( one,             f_e_half_bias    );
  const uint32_t f_m_with_hidden            = _uint32_or(  f_m_rounded,     f_m_hidden_bit   );
  const uint32_t f_m_denorm                 = _uint32_srl( f_m_with_hidden, f_m_denorm_sa    );
  const uint32_t h_m_denorm                 = _uint32_srl( f_m_denorm,      f_h_m_pos_offset );
  const uint32_t f_m_rounded_overflow       = _uint32_and( f_m_rounded,     f_m_hidden_bit   );
  const uint32_t m_nan                      = _uint32_srl( f_m,             f_h_m_pos_offset );
  const uint32_t h_em_nan                   = _uint32_or(  h_e_mask,        m_nan            );
  const uint32_t h_e_norm_overflow_offset   = _uint32_inc( f_e_half_bias );
  const uint32_t h_e_norm_overflow          = _uint32_sll( h_e_norm_overflow_offset, h_e_pos          );
  const uint32_t h_e_norm                   = _uint32_sll( f_e_half_bias,            h_e_pos          );
  const uint32_t h_m_norm                   = _uint32_srl( f_m_rounded,              f_h_m_pos_offset );
  const uint32_t h_em_norm                  = _uint32_or(  h_e_norm,                 h_m_norm         );
  const uint32_t is_h_ndenorm_msb           = _uint32_sub( f_h_bias_offset,   f_e_amount    );
  const uint32_t is_f_e_flagged_msb         = _uint32_sub( f_h_e_biased_flag, f_e_half_bias );
  const uint32_t is_h_denorm_msb            = _uint32_not( is_h_ndenorm_msb );
  const uint32_t is_f_m_eqz_msb             = _uint32_dec( f_m   );
  const uint32_t is_h_nan_eqz_msb           = _uint32_dec( m_nan );
  const uint32_t is_f_inf_msb               = _uint32_and( is_f_e_flagged_msb, is_f_m_eqz_msb   );
  const uint32_t is_f_nan_underflow_msb     = _uint32_and( is_f_e_flagged_msb, is_h_nan_eqz_msb );
  const uint32_t is_e_overflow_msb          = _uint32_sub( h_e_mask_value,     f_e_half_bias    );
  const uint32_t is_h_inf_msb               = _uint32_or(  is_e_overflow_msb,  is_f_inf_msb     );
  const uint32_t is_f_nsnan_msb             = _uint32_sub( f_snan,             f_snan_mask      );
  const uint32_t is_m_norm_overflow_msb     = _uint32_neg( f_m_rounded_overflow );
  const uint32_t is_f_snan_msb              = _uint32_not( is_f_nsnan_msb );
  const uint32_t h_em_overflow_result       = _uint32_sels( is_m_norm_overflow_msb, h_e_norm_overflow, h_em_norm                 );
  const uint32_t h_em_nan_result            = _uint32_sels( is_f_e_flagged_msb,     h_em_nan,          h_em_overflow_result      );
  const uint32_t h_em_nan_underflow_result  = _uint32_sels( is_f_nan_underflow_msb, h_nan_min,         h_em_nan_result           );
  const uint32_t h_em_inf_result            = _uint32_sels( is_h_inf_msb,           h_e_mask,          h_em_nan_underflow_result );
  const uint32_t h_em_denorm_result         = _uint32_sels( is_h_denorm_msb,        h_m_denorm,        h_em_inf_result           );
  const uint32_t h_em_snan_result           = _uint32_sels( is_f_snan_msb,          h_snan_mask,       h_em_denorm_result        );
  const uint32_t h_result                   = _uint32_or( h_s, h_em_snan_result );

  return (uint16_t)(h_result);
}

uint32_t 
half_to_float( uint16_t h )
{
  const uint32_t h_e_mask              = _uint32_li( 0x00007c00 );
  const uint32_t h_m_mask              = _uint32_li( 0x000003ff );
  const uint32_t h_s_mask              = _uint32_li( 0x00008000 );
  const uint32_t h_f_s_pos_offset      = _uint32_li( 0x00000010 );
  const uint32_t h_f_e_pos_offset      = _uint32_li( 0x0000000d );
  const uint32_t h_f_bias_offset       = _uint32_li( 0x0001c000 );
  const uint32_t f_e_mask              = _uint32_li( 0x7f800000 );
  const uint32_t f_m_mask              = _uint32_li( 0x007fffff );
  const uint32_t h_f_e_denorm_bias     = _uint32_li( 0x0000007e );
  const uint32_t h_f_m_denorm_sa_bias  = _uint32_li( 0x00000008 );
  const uint32_t f_e_pos               = _uint32_li( 0x00000017 );
  const uint32_t h_e_mask_minus_one    = _uint32_li( 0x00007bff );
  const uint32_t h_e                   = _uint32_and( h, h_e_mask );
  const uint32_t h_m                   = _uint32_and( h, h_m_mask );
  const uint32_t h_s                   = _uint32_and( h, h_s_mask );
  const uint32_t h_e_f_bias            = _uint32_add( h_e, h_f_bias_offset );
  const uint32_t h_m_nlz               = _uint32_cntlz( h_m );
  const uint32_t f_s                   = _uint32_sll( h_s,        h_f_s_pos_offset );
  const uint32_t f_e                   = _uint32_sll( h_e_f_bias, h_f_e_pos_offset );
  const uint32_t f_m                   = _uint32_sll( h_m,        h_f_e_pos_offset );
  const uint32_t f_em                  = _uint32_or(  f_e,        f_m              );
  const uint32_t h_f_m_sa              = _uint32_sub( h_m_nlz,             h_f_m_denorm_sa_bias );
  const uint32_t f_e_denorm_unpacked   = _uint32_sub( h_f_e_denorm_bias,   h_f_m_sa             );
  const uint32_t h_f_m                 = _uint32_sll( h_m,                 h_f_m_sa             );
  const uint32_t f_m_denorm            = _uint32_and( h_f_m,               f_m_mask             );
  const uint32_t f_e_denorm            = _uint32_sll( f_e_denorm_unpacked, f_e_pos              );
  const uint32_t f_em_denorm           = _uint32_or(  f_e_denorm,          f_m_denorm           );
  const uint32_t f_em_nan              = _uint32_or(  f_e_mask,            f_m                  );
  const uint32_t is_e_eqz_msb          = _uint32_dec(  h_e );
  const uint32_t is_m_nez_msb          = _uint32_neg(  h_m );
  const uint32_t is_e_flagged_msb      = _uint32_sub(  h_e_mask_minus_one, h_e );
  const uint32_t is_zero_msb           = _uint32_andc( is_e_eqz_msb,       is_m_nez_msb );
  const uint32_t is_inf_msb            = _uint32_andc( is_e_flagged_msb,   is_m_nez_msb );
  const uint32_t is_denorm_msb         = _uint32_and(  is_m_nez_msb,       is_e_eqz_msb );
  const uint32_t is_nan_msb            = _uint32_and(  is_e_flagged_msb,   is_m_nez_msb ); 
  const uint32_t is_zero               = _uint32_ext(  is_zero_msb );
  const uint32_t f_zero_result         = _uint32_andc( f_em, is_zero );
  const uint32_t f_denorm_result       = _uint32_sels( is_denorm_msb, f_em_denorm, f_zero_result );
  const uint32_t f_inf_result          = _uint32_sels( is_inf_msb,    f_e_mask,    f_denorm_result );
  const uint32_t f_nan_result          = _uint32_sels( is_nan_msb,    f_em_nan,    f_inf_result    );
  const uint32_t f_result              = _uint32_or( f_s, f_nan_result );
 
  return (f_result);
}

// half_add
// --------
//
//  (SUM)        uint16_t z = half_add( x, y );
//  (DIFFERENCE) uint16_t z = half_add( x, -y );
//
//  * Difference of ZEROs is always +ZERO
//  * Sum round with guard + round + sticky bit (grs)
//  * QNaN + <x>  = QNaN
//  * <x>  + +INF = +INF
//  * <x>  - -INF = -INF
//  * INF  - INF  = SNaN
//
//  Will have exactly (0 ulps difference) the same result as:
//  (Round up)
//
//     union FLOAT_32
//     {
//       float    f32;
//       uint32_t u32;
//     };
//
//     union FLOAT_32 fx = { .u32 = half_to_float( x ) };
//     union FLOAT_32 fy = { .u32 = half_to_float( y ) };
//     union FLOAT_32 fz = { .f32 = fx.f32 + fy.f32    };
//     uint16_t       z  = float_to_half( fz );
//
uint16_t
half_add( uint16_t x, uint16_t y )
{
  const uint16_t one                       = _uint16_li( 0x0001 );
  const uint16_t msb_to_lsb_sa             = _uint16_li( 0x000f );
  const uint16_t h_s_mask                  = _uint16_li( 0x8000 );
  const uint16_t h_e_mask                  = _uint16_li( 0x7c00 );
  const uint16_t h_m_mask                  = _uint16_li( 0x03ff );
  const uint16_t h_m_msb_mask              = _uint16_li( 0x2000 );
  const uint16_t h_m_msb_sa                = _uint16_li( 0x000d );
  const uint16_t h_m_hidden                = _uint16_li( 0x0400 );
  const uint16_t h_e_pos                   = _uint16_li( 0x000a );
  const uint16_t h_e_bias_minus_one        = _uint16_li( 0x000e );
  const uint16_t h_m_grs_carry             = _uint16_li( 0x4000 );
  const uint16_t h_m_grs_carry_pos         = _uint16_li( 0x000e );
  const uint16_t h_grs_size                = _uint16_li( 0x0003 );
  const uint16_t h_snan                    = _uint16_li( 0xfe00 );
  const uint16_t h_e_mask_minus_one        = _uint16_li( 0x7bff );
  const uint16_t h_grs_round_carry         = _uint16_sll( one, h_grs_size );
  const uint16_t h_grs_round_mask          = _uint16_sub( h_grs_round_carry, one );
  const uint16_t x_e                       = _uint16_and( x, h_e_mask );
  const uint16_t y_e                       = _uint16_and( y, h_e_mask );
  const uint16_t is_y_e_larger_msb         = _uint16_sub( x_e, y_e );
  const uint16_t a                         = _uint16_sels( is_y_e_larger_msb, y, x);
  const uint16_t a_s                       = _uint16_and( a, h_s_mask );
  const uint16_t a_e                       = _uint16_and( a, h_e_mask );
  const uint16_t a_m_no_hidden_bit         = _uint16_and( a, h_m_mask );
  const uint16_t a_em_no_hidden_bit        = _uint16_or( a_e, a_m_no_hidden_bit );
  const uint16_t b                         = _uint16_sels( is_y_e_larger_msb, x, y);
  const uint16_t b_s                       = _uint16_and( b, h_s_mask );
  const uint16_t b_e                       = _uint16_and( b, h_e_mask );
  const uint16_t b_m_no_hidden_bit         = _uint16_and( b, h_m_mask );
  const uint16_t b_em_no_hidden_bit        = _uint16_or( b_e, b_m_no_hidden_bit );
  const uint16_t is_diff_sign_msb          = _uint16_xor( a_s, b_s );
  const uint16_t is_a_inf_msb              = _uint16_sub( h_e_mask_minus_one, a_em_no_hidden_bit );
  const uint16_t is_b_inf_msb              = _uint16_sub( h_e_mask_minus_one, b_em_no_hidden_bit );
  const uint16_t is_undenorm_msb           = _uint16_dec( a_e );
  const uint16_t is_undenorm               = _uint16_ext( is_undenorm_msb );
  const uint16_t is_both_inf_msb           = _uint16_and( is_a_inf_msb, is_b_inf_msb );
  const uint16_t is_invalid_inf_op_msb     = _uint16_and( is_both_inf_msb, b_s );
  const uint16_t is_a_e_nez_msb            = _uint16_neg( a_e );
  const uint16_t is_b_e_nez_msb            = _uint16_neg( b_e );
  const uint16_t is_a_e_nez                = _uint16_ext( is_a_e_nez_msb );
  const uint16_t is_b_e_nez                = _uint16_ext( is_b_e_nez_msb );
  const uint16_t a_m_hidden_bit            = _uint16_and( is_a_e_nez, h_m_hidden );
  const uint16_t b_m_hidden_bit            = _uint16_and( is_b_e_nez, h_m_hidden );
  const uint16_t a_m_no_grs                = _uint16_or( a_m_no_hidden_bit, a_m_hidden_bit );
  const uint16_t b_m_no_grs                = _uint16_or( b_m_no_hidden_bit, b_m_hidden_bit );
  const uint16_t diff_e                    = _uint16_sub( a_e,        b_e );
  const uint16_t a_e_unbias                = _uint16_sub( a_e,        h_e_bias_minus_one );
  const uint16_t a_m                       = _uint16_sll( a_m_no_grs, h_grs_size );
  const uint16_t a_e_biased                = _uint16_srl( a_e,        h_e_pos );
  const uint16_t m_sa_unbias               = _uint16_srl( a_e_unbias, h_e_pos );
  const uint16_t m_sa_default              = _uint16_srl( diff_e,     h_e_pos );
  const uint16_t m_sa_unbias_mask          = _uint16_andc( is_a_e_nez_msb,   is_b_e_nez_msb );
  const uint16_t m_sa                      = _uint16_sels( m_sa_unbias_mask, m_sa_unbias, m_sa_default );
  const uint16_t b_m_no_sticky             = _uint16_sll( b_m_no_grs,        h_grs_size );
  const uint16_t sh_m                      = _uint16_srl( b_m_no_sticky,     m_sa );
  const uint16_t sticky_overflow           = _uint16_sll( one,               m_sa );
  const uint16_t sticky_mask               = _uint16_dec( sticky_overflow );
  const uint16_t sticky_collect            = _uint16_and( b_m_no_sticky, sticky_mask );
  const uint16_t is_sticky_set_msb         = _uint16_neg( sticky_collect );
  const uint16_t sticky                    = _uint16_srl( is_sticky_set_msb, msb_to_lsb_sa);
  const uint16_t b_m                       = _uint16_or( sh_m, sticky );
  const uint16_t is_c_m_ab_pos_msb         = _uint16_sub( b_m, a_m );
  const uint16_t c_inf                     = _uint16_or( a_s, h_e_mask );
  const uint16_t c_m_sum                   = _uint16_add( a_m, b_m );
  const uint16_t c_m_diff_ab               = _uint16_sub( a_m, b_m );
  const uint16_t c_m_diff_ba               = _uint16_sub( b_m, a_m );
  const uint16_t c_m_smag_diff             = _uint16_sels( is_c_m_ab_pos_msb, c_m_diff_ab, c_m_diff_ba );
  const uint16_t c_s_diff                  = _uint16_sels( is_c_m_ab_pos_msb, a_s,         b_s         );
  const uint16_t c_s                       = _uint16_sels( is_diff_sign_msb,  c_s_diff,    a_s         );
  const uint16_t c_m_smag_diff_nlz         = _uint16_cntlz( c_m_smag_diff );
  const uint16_t diff_norm_sa              = _uint16_sub( c_m_smag_diff_nlz, one );
  const uint16_t is_diff_denorm_msb        = _uint16_sub( a_e_biased, diff_norm_sa );
  const uint16_t is_diff_denorm            = _uint16_ext( is_diff_denorm_msb );
  const uint16_t is_a_or_b_norm_msb        = _uint16_neg( a_e_biased );
  const uint16_t diff_denorm_sa            = _uint16_dec( a_e_biased );
  const uint16_t c_m_diff_denorm           = _uint16_sll( c_m_smag_diff, diff_denorm_sa );
  const uint16_t c_m_diff_norm             = _uint16_sll( c_m_smag_diff, diff_norm_sa );
  const uint16_t c_e_diff_norm             = _uint16_sub( a_e_biased,  diff_norm_sa );
  const uint16_t c_m_diff_ab_norm          = _uint16_sels( is_diff_denorm_msb, c_m_diff_denorm, c_m_diff_norm );
  const uint16_t c_e_diff_ab_norm          = _uint16_andc( c_e_diff_norm, is_diff_denorm );
  const uint16_t c_m_diff                  = _uint16_sels( is_a_or_b_norm_msb, c_m_diff_ab_norm, c_m_smag_diff );
  const uint16_t c_e_diff                  = _uint16_sels( is_a_or_b_norm_msb, c_e_diff_ab_norm, a_e_biased    );
  const uint16_t is_diff_eqz_msb           = _uint16_dec( c_m_diff );
  const uint16_t is_diff_exactly_zero_msb  = _uint16_and( is_diff_sign_msb, is_diff_eqz_msb );
  const uint16_t is_diff_exactly_zero      = _uint16_ext( is_diff_exactly_zero_msb );
  const uint16_t c_m_added                 = _uint16_sels( is_diff_sign_msb, c_m_diff, c_m_sum );
  const uint16_t c_e_added                 = _uint16_sels( is_diff_sign_msb, c_e_diff, a_e_biased );
  const uint16_t c_m_carry                 = _uint16_and( c_m_added, h_m_grs_carry );
  const uint16_t is_c_m_carry_msb          = _uint16_neg( c_m_carry );
  const uint16_t c_e_hidden_offset         = _uint16_andsrl( c_m_added, h_m_grs_carry, h_m_grs_carry_pos );
  const uint16_t c_m_sub_hidden            = _uint16_srl( c_m_added, one );
  const uint16_t c_m_no_hidden             = _uint16_sels( is_c_m_carry_msb, c_m_sub_hidden, c_m_added );
  const uint16_t c_e_no_hidden             = _uint16_add( c_e_added,         c_e_hidden_offset  );
  const uint16_t c_m_no_hidden_msb         = _uint16_and( c_m_no_hidden,     h_m_msb_mask       );
  const uint16_t undenorm_m_msb_odd        = _uint16_srl( c_m_no_hidden_msb, h_m_msb_sa         );
  const uint16_t undenorm_fix_e            = _uint16_and( is_undenorm,       undenorm_m_msb_odd );
  const uint16_t c_e_fixed                 = _uint16_add( c_e_no_hidden,     undenorm_fix_e     );
  const uint16_t c_m_round_amount          = _uint16_and( c_m_no_hidden,     h_grs_round_mask   );
  const uint16_t c_m_rounded               = _uint16_add( c_m_no_hidden,     c_m_round_amount   );
  const uint16_t c_m_round_overflow        = _uint16_andsrl( c_m_rounded, h_m_grs_carry, h_m_grs_carry_pos );
  const uint16_t c_e_rounded               = _uint16_add( c_e_fixed, c_m_round_overflow );
  const uint16_t c_m_no_grs                = _uint16_srlm( c_m_rounded, h_grs_size,  h_m_mask );
  const uint16_t c_e                       = _uint16_sll( c_e_rounded, h_e_pos );
  const uint16_t c_em                      = _uint16_or( c_e, c_m_no_grs );
  const uint16_t c_normal                  = _uint16_or( c_s, c_em );
  const uint16_t c_inf_result              = _uint16_sels( is_a_inf_msb, c_inf, c_normal );
  const uint16_t c_zero_result             = _uint16_andc( c_inf_result, is_diff_exactly_zero );
  const uint16_t c_result                  = _uint16_sels( is_invalid_inf_op_msb, h_snan, c_zero_result );

  return (c_result);
}

// half_mul
// --------
//
//  May have 0 or 1 ulp difference from the following result:
//  (Round to nearest) 
//  NOTE: Rounding mode differs between conversion and multiply
//
//     union FLOAT_32
//     {
//       float    f32;
//       uint32_t u32;
//     };
//
//     union FLOAT_32 fx = { .u32 = half_to_float( x ) };
//     union FLOAT_32 fy = { .u32 = half_to_float( y ) };
//     union FLOAT_32 fz = { .f32 = fx.f32 * fy.f32    };
//     uint16_t       z  = float_to_half( fz );
//
uint16_t
half_mul( uint16_t x, uint16_t y )
{
  const uint32_t one                                = _uint32_li( 0x00000001 );
  const uint32_t h_s_mask                           = _uint32_li( 0x00008000 );
  const uint32_t h_e_mask                           = _uint32_li( 0x00007c00 );
  const uint32_t h_m_mask                           = _uint32_li( 0x000003ff );
  const uint32_t h_m_hidden                         = _uint32_li( 0x00000400 );
  const uint32_t h_e_pos                            = _uint32_li( 0x0000000a );
  const uint32_t h_e_bias                           = _uint32_li( 0x0000000f );
  const uint32_t h_m_bit_count                      = _uint32_li( 0x0000000a );
  const uint32_t h_m_bit_half_count                 = _uint32_li( 0x00000005 );
  const uint32_t h_nan_min                          = _uint32_li( 0x00007c01 );
  const uint32_t h_e_mask_minus_one                 = _uint32_li( 0x00007bff );
  const uint32_t h_snan                             = _uint32_li( 0x0000fe00 );
  const uint32_t m_round_overflow_bit               = _uint32_li( 0x00000020 );
  const uint32_t m_hidden_bit                       = _uint32_li( 0x00100000 );
  const uint32_t a_s                                = _uint32_and(  x,   h_s_mask );
  const uint32_t b_s                                = _uint32_and(  y,   h_s_mask );
  const uint32_t c_s                                = _uint32_xor(  a_s, b_s      );
  const uint32_t x_e                                = _uint32_and(  x,   h_e_mask );
  const uint32_t x_e_eqz_msb                        = _uint32_dec(  x_e );
  const uint32_t a                                  = _uint32_sels( x_e_eqz_msb, y, x );
  const uint32_t b                                  = _uint32_sels( x_e_eqz_msb, x, y );
  const uint32_t a_e                                = _uint32_and(  a,   h_e_mask );
  const uint32_t b_e                                = _uint32_and(  b,   h_e_mask );
  const uint32_t a_m                                = _uint32_and(  a,   h_m_mask );
  const uint32_t b_m                                = _uint32_and(  b,   h_m_mask );
  const uint32_t a_e_amount                         = _uint32_srl(  a_e,                 h_e_pos                 );
  const uint32_t b_e_amount                         = _uint32_srl(  b_e,                 h_e_pos                 );
  const uint32_t a_m_with_hidden                    = _uint32_or(   a_m,                 h_m_hidden              );
  const uint32_t b_m_with_hidden                    = _uint32_or(   b_m,                 h_m_hidden              );
  const uint32_t c_m_normal                         = _uint32_mul(  a_m_with_hidden,     b_m_with_hidden         );
  const uint32_t c_m_denorm_biased                  = _uint32_mul(  a_m_with_hidden,     b_m                     );
  const uint32_t c_e_denorm_unbias_e                = _uint32_sub(  h_e_bias,            a_e_amount              );
  const uint32_t c_m_denorm_round_amount            = _uint32_and(  c_m_denorm_biased,   h_m_mask                );
  const uint32_t c_m_denorm_rounded                 = _uint32_add(  c_m_denorm_biased,   c_m_denorm_round_amount );
  const uint32_t c_m_denorm_inplace                 = _uint32_srl(  c_m_denorm_rounded,  h_m_bit_count           );
  const uint32_t c_m_denorm_unbiased                = _uint32_srl(  c_m_denorm_inplace,  c_e_denorm_unbias_e     );
  const uint32_t c_m_denorm                         = _uint32_and(  c_m_denorm_unbiased, h_m_mask                );
  const uint32_t c_e_amount_biased                  = _uint32_add(  a_e_amount,          b_e_amount              );
  const uint32_t c_e_amount_unbiased                = _uint32_sub(  c_e_amount_biased,   h_e_bias                );
  const uint32_t is_c_e_unbiased_underflow          = _uint32_ext(  c_e_amount_unbiased );
  const uint32_t c_e_underflow_half_sa              = _uint32_neg(  c_e_amount_unbiased );
  const uint32_t c_e_underflow_sa                   = _uint32_sll(  c_e_underflow_half_sa,     one );
  const uint32_t c_m_underflow                      = _uint32_srl(  c_m_normal,                c_e_underflow_sa );
  const uint32_t c_e_underflow_added                = _uint32_andc( c_e_amount_unbiased,       is_c_e_unbiased_underflow );
  const uint32_t c_m_underflow_added                = _uint32_selb( is_c_e_unbiased_underflow, c_m_underflow, c_m_normal );
  const uint32_t is_mul_overflow_test               = _uint32_and(  c_e_underflow_added, m_round_overflow_bit );
  const uint32_t is_mul_overflow_msb                = _uint32_neg(  is_mul_overflow_test );
  const uint32_t c_e_norm_radix_corrected           = _uint32_inc(  c_e_underflow_added );
  const uint32_t c_m_norm_radix_corrected           = _uint32_srl(  c_m_underflow_added, one );
  const uint32_t c_m_norm_hidden_bit                = _uint32_and(  c_m_norm_radix_corrected,  m_hidden_bit );
  const uint32_t is_c_m_norm_no_hidden_msb          = _uint32_dec(  c_m_norm_hidden_bit );
  const uint32_t c_m_norm_lo                        = _uint32_srl(  c_m_norm_radix_corrected, h_m_bit_half_count );
  const uint32_t c_m_norm_lo_nlz                    = _uint16_cntlz( c_m_norm_lo );
  const uint32_t is_c_m_hidden_nunderflow_msb       = _uint32_sub(  c_m_norm_lo_nlz, c_e_norm_radix_corrected );
  const uint32_t is_c_m_hidden_underflow_msb        = _uint32_not(  is_c_m_hidden_nunderflow_msb );
  const uint32_t is_c_m_hidden_underflow            = _uint32_ext(  is_c_m_hidden_underflow_msb  );
  const uint32_t c_m_hidden_underflow_normalized_sa = _uint32_srl(  c_m_norm_lo_nlz, one );
  const uint32_t c_m_hidden_underflow_normalized    = _uint32_sll(  c_m_norm_radix_corrected, c_m_hidden_underflow_normalized_sa );
  const uint32_t c_m_hidden_normalized              = _uint32_sll(  c_m_norm_radix_corrected, c_m_norm_lo_nlz );
  const uint32_t c_e_hidden_normalized              = _uint32_sub(  c_e_norm_radix_corrected, c_m_norm_lo_nlz );
  const uint32_t c_e_hidden                         = _uint32_andc( c_e_hidden_normalized, is_c_m_hidden_underflow );
  const uint32_t c_m_hidden                         = _uint32_sels( is_c_m_hidden_underflow_msb, c_m_hidden_underflow_normalized, c_m_hidden_normalized );
  const uint32_t c_m_normalized                     = _uint32_sels( is_c_m_norm_no_hidden_msb, c_m_hidden, c_m_norm_radix_corrected );
  const uint32_t c_e_normalized                     = _uint32_sels( is_c_m_norm_no_hidden_msb, c_e_hidden, c_e_norm_radix_corrected );
  const uint32_t c_m_norm_round_amount              = _uint32_and(  c_m_normalized, h_m_mask );
  const uint32_t c_m_norm_rounded                   = _uint32_add(  c_m_normalized, c_m_norm_round_amount );
  const uint32_t is_round_overflow_test             = _uint32_and(  c_e_normalized, m_round_overflow_bit  );
  const uint32_t is_round_overflow_msb              = _uint32_neg(  is_round_overflow_test );
  const uint32_t c_m_norm_inplace                   = _uint32_srl(  c_m_norm_rounded,    h_m_bit_count );
  const uint32_t c_m                                = _uint32_and(  c_m_norm_inplace,    h_m_mask      );
  const uint32_t c_e_norm_inplace                   = _uint32_sll(  c_e_normalized, h_e_pos       );
  const uint32_t c_e                                = _uint32_and(  c_e_norm_inplace,    h_e_mask      );
  const uint32_t c_em_nan                           = _uint32_or(   h_e_mask,  a_m        );
  const uint32_t c_nan                              = _uint32_or(   a_s,       c_em_nan   );
  const uint32_t c_denorm                           = _uint32_or(   c_s,       c_m_denorm );
  const uint32_t c_inf                              = _uint32_or(   c_s,       h_e_mask   );
  const uint32_t c_em_norm                          = _uint32_or(   c_e,       c_m        );
  const uint32_t is_a_e_flagged_msb                 = _uint32_sub(  h_e_mask_minus_one, a_e );
  const uint32_t is_b_e_flagged_msb                 = _uint32_sub(  h_e_mask_minus_one, b_e );
  const uint32_t is_a_e_eqz_msb                     = _uint32_dec(  a_e );
  const uint32_t is_a_m_eqz_msb                     = _uint32_dec(  a_m );
  const uint32_t is_b_e_eqz_msb                     = _uint32_dec(  b_e );
  const uint32_t is_b_m_eqz_msb                     = _uint32_dec(  b_m );
  const uint32_t is_b_eqz_msb                       = _uint32_and(  is_b_e_eqz_msb,          is_b_m_eqz_msb         );
  const uint32_t is_a_eqz_msb                       = _uint32_and(  is_a_e_eqz_msb,          is_a_m_eqz_msb         );
  const uint32_t is_c_nan_via_a_msb                 = _uint32_andc( is_a_e_flagged_msb,      is_b_e_flagged_msb     );
  const uint32_t is_c_nan_via_b_msb                 = _uint32_andc( is_b_e_flagged_msb,      is_b_m_eqz_msb         );
  const uint32_t is_c_nan_msb                       = _uint32_or(   is_c_nan_via_a_msb,      is_c_nan_via_b_msb     );
  const uint32_t is_c_denorm_msb                    = _uint32_andc( is_b_e_eqz_msb,          is_a_e_flagged_msb     );
  const uint32_t is_a_inf_msb                       = _uint32_and(  is_a_e_flagged_msb,      is_a_m_eqz_msb         );
  const uint32_t is_c_snan_msb                      = _uint32_and(  is_a_inf_msb,            is_b_eqz_msb           );
  const uint32_t is_c_nan_min_via_a_msb             = _uint32_and(  is_a_e_flagged_msb,      is_b_eqz_msb           );
  const uint32_t is_c_nan_min_via_b_msb             = _uint32_and(  is_b_e_flagged_msb,      is_a_eqz_msb           );
  const uint32_t is_c_nan_min_msb                   = _uint32_or(   is_c_nan_min_via_a_msb,  is_c_nan_min_via_b_msb );
  const uint32_t is_c_inf_msb                       = _uint32_or(   is_a_e_flagged_msb,      is_b_e_flagged_msb     );
  const uint32_t is_overflow_msb                    = _uint32_or(   is_round_overflow_msb,   is_mul_overflow_msb    );
  const uint32_t c_em_overflow_result               = _uint32_sels( is_overflow_msb, h_e_mask, c_em_norm );
  const uint32_t c_common_result                    = _uint32_or(   c_s, c_em_overflow_result );
  const uint32_t c_zero_result                      = _uint32_sels( is_b_eqz_msb,     c_s,       c_common_result  );
  const uint32_t c_nan_result                       = _uint32_sels( is_c_nan_msb,     c_nan,     c_zero_result );
  const uint32_t c_nan_min_result                   = _uint32_sels( is_c_nan_min_msb, h_nan_min, c_nan_result     );
  const uint32_t c_inf_result                       = _uint32_sels( is_c_inf_msb,     c_inf,     c_nan_min_result   );
  const uint32_t c_denorm_result                    = _uint32_sels( is_c_denorm_msb,  c_denorm,  c_inf_result);
  const uint32_t c_result                           = _uint32_sels( is_c_snan_msb,    h_snan,    c_denorm_result );

  return (uint16_t)(c_result);
}
